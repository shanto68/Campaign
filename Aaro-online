# ==== job.py ====
import time
import random
import threading
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.keys import Keys

# Configuration
MASTER_URL = "https://sites.google.com/view/aaroonline/home"
MIN_STAY_TIME = 80
MAX_STAY_TIME = 150
REPORT_URL = "https://organic-traffic.ct.ws/index.php"
CAMPAIGN_ID = "ABC123"  # Campaign ID
USER_ID = "user1"  # User ID
MIN_IMPRESSION = 25  # Minimum impression count
MAX_IMPRESSION = 35  # Maximum impression count

# Global variables for session tracking
click_count = 0
impression_count = 0
pageviews = 0
session_start_time = time.time()
device = "desktop"  # Default to desktop, can be auto-detected
country = "US"  # Default to US, can be detected from IP or configuration

# Thread lock for thread safety
session_lock = threading.Lock()

def generate_report_url():
    """Generate the report URL with current session data"""
    with session_lock:
        # Calculate session time in seconds
        session_time = int(time.time() - session_start_time)
        
        # Generate the report URL
        url = f"{REPORT_URL}?campaignid={CAMPAIGN_ID}&userid={USER_ID}"
        url += f"&impression={impression_count}"
        url += f"&click={click_count}"
        url += f"&session={session_time}"
        url += f"&pageviews={pageviews}"
        url += f"&device={device}"
        url += f"&country={country}"
        
        return url

def show_report_window(driver):
    """Open report URL in a new window for 5 seconds"""
    try:
        # Save current window handle
        original_window = driver.current_window_handle
        
        # Generate report URL
        report_url = generate_report_url()
        
        # Print report details
        print("üìä Session Report:")
        print(f"   Report URL: {report_url}")
        print(f"   - Clicks: {click_count}")
        print(f"   - Impressions: {impression_count}")
        print(f"   - Pageviews: {pageviews}")
        print(f"   - Session Time: {int(time.time() - session_start_time)} seconds")
        print(f"   - Device: {device}")
        print(f"   - Country: {country}")
        
        # Open new window
        driver.execute_script("window.open('');")
        
        # Switch to new window
        driver.switch_to.window(driver.window_handles[-1])
        
        # Load report URL
        driver.get(report_url)
        
        # Wait for 5 seconds
        time.sleep(5)
        
        # Close the new window
        driver.close()
        
        # Switch back to original window
        driver.switch_to.window(original_window)
        
        print("‚úÖ Report window closed")
        
    except Exception as e:
        print(f"‚ö†Ô∏è Error showing report window: {str(e)[:100]}")

def increment_click_count():
    """Safely increment the click count and set impression count"""
    global click_count, impression_count
    with session_lock:
        click_count += 1
        # Set impression count to a random number between MIN_IMPRESSION and MAX_IMPRESSION
        impression_count = random.randint(MIN_IMPRESSION, MAX_IMPRESSION)
        print(f"üî¢ Click count: {click_count}, Impression count: {impression_count}")

def increment_pageviews():
    """Safely increment the pageviews count"""
    global pageviews
    with session_lock:
        pageviews += 1
        print(f"üî¢ Pageviews count: {pageviews}")

def detect_device(driver):
    """Detect device type using custom distribution (35% desktop/mac/ipad/tablet, 65% mobile/iphone/android)"""
    try:
        # Get user agent string for information only
        user_agent = driver.execute_script("return navigator.userAgent;")
        print(f"üÜî User Agent: {user_agent}")
        
        # Custom device distribution:
        # 35% chance for desktop/mac/ipad/tablet
        # 65% chance for mobile/iphone/android
        if random.random() < 0.35:
            # 35% chance for group1
            device_group = ["desktop", "mac", "ipad", "tablet"]
            selected_device = random.choice(device_group)
            print(f"üé≤ Device selected from group1 (35%): {selected_device}")
            return selected_device
        else:
            # 65% chance for group2
            device_group = ["mobile", "iphone", "android"]
            selected_device = random.choice(device_group)
            print(f"üé≤ Device selected from group2 (65%): {selected_device}")
            return selected_device
    except Exception as e:
        print(f"‚ö†Ô∏è Error detecting device: {str(e)[:100]}")
        return "desktop"  # Default to desktop if detection fails

# Persistent cookie handling thread
def cookie_thread(driver, stop_event):
    """Continuously monitors and handles cookies/popups throughout the session"""
    while not stop_event.is_set():
        try:
            # Accept cookies if found
            accept_cookies(driver)
            
            # Close any popups
            close_popups(driver)
            
            # Random delay between checks (5-15 seconds)
            time.sleep(random.uniform(5, 15))
        except Exception as e:
            print(f"‚ö†Ô∏è Cookie thread error: {str(e)[:100]}")

def human_like_scroll(driver, total_time):
    """Enhanced human-like scrolling with 25+ patterns"""
    print(f"üìú Starting advanced human-like scroll for {total_time} seconds...")
    actions = ActionChains(driver)
    start_time = time.time()
    elapsed = 0
    
    # Define 25+ scrolling patterns with weights
    SCROLL_PATTERNS = [
        ("smooth", 0.15, lambda: random.randint(200, 800)),
        ("hesitate", 0.08, None),
        ("slow_jump", 0.10, lambda: random.randint(300, 1000)),
        ("page", 0.05, None),
        ("quick_jump", 0.07, lambda: random.randint(500, 1200)),
        ("back_and_forth", 0.06, None),
        ("random_walk", 0.09, None),
        ("long_hesitate", 0.04, None),
        ("scroll_to_bottom", 0.03, None),
        ("scroll_to_top", 0.03, None),
        ("smooth_medium", 0.06, lambda: random.randint(150, 600)),
        ("hesitate_short", 0.05, None),
        ("slow_smooth", 0.06, lambda: random.randint(100, 400)),
        ("page_up", 0.03, None),
        ("quick_up_jump", 0.04, lambda: -random.randint(400, 900)),
        ("back_and_forth_long", 0.04, None),
        ("random_walk_long", 0.05, None),
        ("hesitate_reading", 0.04, None),
        ("half_page_down", 0.03, None),
        ("half_page_up", 0.02, None),
        ("quarter_page_down", 0.03, None),
        ("quarter_page_up", 0.02, None),
        ("flick_down", 0.02, lambda: random.randint(800, 1500)),
        ("flick_up", 0.02, lambda: -random.randint(700, 1300)),
        ("random_mouse_move", 0.03, None),
    ]
    
    while elapsed < total_time:
        remaining = total_time - elapsed
        print(f"‚è≥ Scroll progress: {elapsed}/{total_time} seconds ({(elapsed/total_time)*100:.1f}%)")
        
        # Select random pattern based on weight
        pattern = random.choices(
            SCROLL_PATTERNS, 
            weights=[p[1] for p in SCROLL_PATTERNS]
        )[0]
        
        direction = random.choice([1, -1])
        pattern_name = pattern[0]
        
        try:
            if pattern_name == "smooth":
                distance = pattern[2]() * direction
                driver.execute_script(f"window.scrollBy(0, {distance})")
                delay = random.uniform(0.8, 1.5)
            
            elif pattern_name == "hesitate":
                delay = random.uniform(1.5, 3)
            
            elif pattern_name == "slow_jump":
                distance = pattern[2]() * direction
                driver.execute_script(f"window.scrollBy(0, {distance})")
                delay = random.uniform(2.0, 3.5)
            
            elif pattern_name == "page":
                key = Keys.PAGE_DOWN if direction == 1 else Keys.PAGE_UP
                actions.send_keys(key).perform()
                delay = random.uniform(2.0, 4.0)
            
            elif pattern_name == "quick_jump":
                distance = pattern[2]() * direction
                driver.execute_script(f"window.scrollBy(0, {distance})")
                delay = random.uniform(0.3, 0.7)
            
            elif pattern_name == "back_and_forth":
                # Scroll sequence: down -> up -> down
                driver.execute_script("window.scrollBy(0, 400)")
                time.sleep(random.uniform(0.5, 1.0))
                driver.execute_script("window.scrollBy(0, -200)")
                time.sleep(random.uniform(0.5, 1.0))
                driver.execute_script("window.scrollBy(0, 300)")
                delay = random.uniform(1.0, 1.5)
            
            elif pattern_name == "random_walk":
                total_delay = 0
                for _ in range(random.randint(2, 5)):
                    distance = random.randint(100, 400) * random.choice([1, -1])
                    driver.execute_script(f"window.scrollBy(0, {distance})")
                    d = random.uniform(0.3, 0.7)
                    time.sleep(d)
                    total_delay += d
                delay = total_delay
            
            elif pattern_name == "long_hesitate":
                delay = random.uniform(3, 5)
            
            elif pattern_name == "scroll_to_bottom":
                driver.execute_script("window.scrollTo(0, document.body.scrollHeight)")
                delay = random.uniform(2.0, 4.0)
            
            elif pattern_name == "scroll_to_top":
                driver.execute_script("window.scrollTo(0, 0)")
                delay = random.uniform(2.0, 4.0)
            
            elif pattern_name == "smooth_medium":
                distance = pattern[2]() * direction
                driver.execute_script(f"window.scrollBy(0, {distance})")
                delay = random.uniform(1.0, 2.0)
            
            elif pattern_name == "hesitate_short":
                delay = random.uniform(0.8, 1.8)
            
            elif pattern_name == "slow_smooth":
                distance = pattern[2]() * direction
                driver.execute_script(f"window.scrollBy(0, {distance})")
                delay = random.uniform(1.5, 2.5)
            
            elif pattern_name == "page_up":
                actions.send_keys(Keys.PAGE_UP).perform()
                delay = random.uniform(2.0, 3.5)
            
            elif pattern_name == "quick_up_jump":
                distance = pattern[2]()
                driver.execute_script(f"window.scrollBy(0, {distance})")
                delay = random.uniform(0.4, 0.9)
            
            elif pattern_name == "back_and_forth_long":
                # Longer scroll sequence
                for _ in range(3):
                    distance = random.randint(300, 600) * random.choice([1, -1])
                    driver.execute_script(f"window.scrollBy(0, {distance})")
                    time.sleep(random.uniform(0.7, 1.2))
                delay = random.uniform(1.5, 2.5)
            
            elif pattern_name == "random_walk_long":
                total_delay = 0
                for _ in range(random.randint(4, 7)):
                    distance = random.randint(80, 250) * random.choice([1, -1])
                    driver.execute_script(f"window.scrollBy(0, {distance})")
                    d = random.uniform(0.2, 0.6)
                    time.sleep(d)
                    total_delay += d
                delay = total_delay
            
            elif pattern_name == "hesitate_reading":
                # Hesitate with small movements
                delay = random.uniform(4, 7)
                for _ in range(2):
                    time.sleep(delay/3)
                    driver.execute_script(f"window.scrollBy(0, {random.randint(50, 150)})")
            
            elif pattern_name == "half_page_down":
                window_h = driver.execute_script("return window.innerHeight")
                driver.execute_script(f"window.scrollBy(0, {window_h//2})")
                delay = random.uniform(1.5, 2.5)
            
            elif pattern_name == "half_page_up":
                window_h = driver.execute_script("return window.innerHeight")
                driver.execute_script(f"window.scrollBy(0, {-window_h//2})")
                delay = random.uniform(1.5, 2.5)
            
            elif pattern_name == "quarter_page_down":
                window_h = driver.execute_script("return window.innerHeight")
                driver.execute_script(f"window.scrollBy(0, {window_h//4})")
                delay = random.uniform(1.0, 2.0)
            
            elif pattern_name == "quarter_page_up":
                window_h = driver.execute_script("return window.innerHeight")
                driver.execute_script(f"window.scrollBy(0, {-window_h//4})")
                delay = random.uniform(1.0, 2.0)
            
            elif pattern_name == "flick_down":
                distance = pattern[2]()
                driver.execute_script(f"window.scrollBy(0, {distance})")
                delay = random.uniform(0.1, 0.3)
            
            elif pattern_name == "flick_up":
                distance = pattern[2]()
                driver.execute_script(f"window.scrollBy(0, {distance})")
                delay = random.uniform(0.1, 0.3)
            
            elif pattern_name == "random_mouse_move":
                # Human-like mouse movement while scrolling
                x_offset = random.randint(-50, 50)
                y_offset = random.randint(-30, 30)
                actions.move_by_offset(x_offset, y_offset).perform()
                distance = random.randint(200, 600) * direction
                driver.execute_script(f"window.scrollBy(0, {distance})")
                delay = random.uniform(1.0, 2.0)
            
            # Execute the delay for all patterns
            time.sleep(delay)
            elapsed += delay
            
            # Debug print pattern
            print(f"üåÄ [{pattern_name}] +{delay:.1f}s")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Scroll error: {str(e)[:100]}")
            delay = random.uniform(1.0, 2.0)
            time.sleep(delay)
            elapsed += delay

def human_like_click(element):
    try:
        actions = ActionChains(element.parent)
        actions.move_to_element(element).pause(random.uniform(0.5, 1.5))
        actions.click().pause(random.uniform(0.2, 0.7))
        actions.perform()
        return True
    except:
        return False

def click_element_if_exists(driver, selector, msg=""):
    try:
        element = driver.find_element(By.CSS_SELECTOR, selector)
        if element.is_displayed():
            human_like_click(element)
            if msg: 
                print(f"‚úÖ {msg}")
            return True
    except:
        pass
    return False

def accept_cookies(driver):
    selectors = [
        'button#cookie-ok', 
        'a[aria-label="Accept cookies"]',
        'button[class*="cookie-accept"]', 
        'div[class*="cookie"] button',
        'a#cookieChoiceDismiss.cookie-choices-button', 
        'a.cookie-choices-button'
    ]
    for selector in selectors:
        if click_element_if_exists(driver, selector, f"Cookie accepted: {selector}"):
            return True
    return False

def close_popups(driver):
    print("‚ùå Checking for popups...")
    selectors = [
        'button.close', 
        'div.modal-close', 
        'a.popup-close', 
        'button[aria-label="Close"]'
    ]
    for selector in selectors:
        try:
            elements = driver.find_elements(By.CSS_SELECTOR, selector)
            for el in elements:
                if el.is_displayed():
                    human_like_click(el)
                    print(f"‚ùå Popup closed: {selector}")
        except:
            continue

def try_accept_consents(driver):
    print("üßê Checking consent buttons...")
    time.sleep(random.randint(4, 13))
    clicked = click_element_if_exists(
        driver, 
        "button.fc-button.fc-cta-consent.fc-primary-button", 
        "Clicked consent button"
    )
    time.sleep(random.randint(4, 13))
    accepted = accept_cookies(driver)
    return clicked or accepted

######### Related Link 
def get_related_links(driver, visited_links):
    print("üîç Finding related links...")
    time.sleep(random.randint(3, 6))
    
    try:
        # 1. Scroll down to the "Related Posts" section
        print("üìú Scrolling to Related Posts section...")
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight)")
        time.sleep(random.uniform(2, 4))
        
        # Look for the "Related Posts" section with class "related-runs"
        try:
            related_section = driver.find_element(By.CLASS_NAME, "related-runs")
            driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", related_section)
            print("‚úÖ Found 'related-runs' section")
        except:
            # Try to find section with "You Might Like" text
            try:
                related_section = driver.find_element(By.XPATH, "//*[contains(text(), 'You Might Like')]")
                driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", related_section)
                print("‚úÖ Found 'You Might Like' section")
            except:
                print("‚ùå Could not find Related Posts section")
                return []
        
        # 2. Wait for all related post links to load properly
        time.sleep(random.uniform(3, 5))
        
        # 3. Get all related links
        valid_links = []
        try:
            links = driver.find_elements(By.CSS_SELECTOR, ".related-runs .entry-title a")
            if not links:
                # Fallback to finding links in the section
                section_elements = driver.find_elements(By.XPATH, "//*[contains(text(), 'You Might Like')]//following-sibling::div//a")
                links = section_elements
            
            for link in links:
                href = link.get_attribute("href")
                if href and href.startswith("http") and href not in visited_links:
                    valid_links.append(href)
            
            if not valid_links:
                print("‚ùå No valid related links found")
                return []
                
            print(f"üîó Found {len(valid_links)} related links")
            
            # 3. Hover over 2-3 random links
            num_to_hover = min(3, len(valid_links))
            if num_to_hover > 0:
                hover_links = random.sample(valid_links, num_to_hover)
                actions = ActionChains(driver)
                
                for link_url in hover_links:
                    try:
                        # Find the element by href
                        element = driver.find_element(By.XPATH, f"//a[@href='{link_url}']")
                        # Natural cursor movement
                        actions.move_to_element(element).pause(random.uniform(1, 2))
                        actions.perform()
                        print(f"üëÜ Hovered over: {link_url}")
                        time.sleep(random.uniform(1, 2))
                    except:
                        continue
            
            # 4. Return all valid links
            return valid_links
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error extracting links: {str(e)[:100]}")
            return []
            
    except Exception as e:
        print(f"‚ö†Ô∏è Error in get_related_links: {str(e)[:100]}")
        return []

################## Related Link
def run_job(driver, session_pages):
    # Reset session counters for each job run
    global click_count, impression_count, pageviews, session_start_time
    click_count = 0
    impression_count = 0
    pageviews = 0
    session_start_time = time.time()
    
    # Start cookie thread
    stop_event = threading.Event()
    cookie_thread_instance = threading.Thread(
        target=cookie_thread, 
        args=(driver, stop_event),
        daemon=True
    )
    cookie_thread_instance.start()
    
    # Track visited links
    visited_links = set()
    
    try:
        # Detect device type
        global device
        device = detect_device(driver)
        print(f"üì± Detected device type: {device}")
        
        # Start at master URL
        print(f"üåç Navigating to master: {MASTER_URL}")
        driver.get(MASTER_URL)
        increment_pageviews()  # Increment pageviews for master URL
        time.sleep(random.uniform(4.5, 7.5))
        
        # Find game/article links from multiple div classes
        div_selectors = [
            'div.tyJCtd.baZpAe',
            'div.tyJCtd.biZpAe',
            'div.tkJCtd.baZpAe'
        ]
        game_links = []
        try:
            for selector in div_selectors:
                divs = driver.find_elements(By.CSS_SELECTOR, selector)
                for div in divs:
                    links = div.find_elements(By.TAG_NAME, 'a')
                    for link in links:
                        href = link.get_attribute("href")
                        if href and href.startswith("http") and href not in game_links:
                            game_links.append(href)
        except Exception as e:
            print(f"‚ö†Ô∏è Error while finding links: {str(e)[:100]}")
        if not game_links:
            print("‚ùå No game/article links found")
            return False
        
        print(f"üîó Found {len(game_links)} game links")
        current_url = random.choice(game_links)
        print(f"‚û°Ô∏è Navigating to game: {current_url}")
        driver.get(current_url)
        increment_pageviews()  # Increment pageviews for the first game
        increment_click_count()  # Increment click count for the first game (only once per session)
        
        # Initial consent handling
        try_accept_consents(driver)
        
        # Session loop
        for page_num in range(1, session_pages + 1):
            print(f"\nüìÑ Session page {page_num}/{session_pages}")
            time.sleep(random.uniform(3.5, 6.5))
            
            # Human-like interaction
            stay_time = random.randint(MIN_STAY_TIME, MAX_STAY_TIME)
            print(f"üïí Staying on page: {stay_time} seconds")
            human_like_scroll(driver, stay_time)
            
            # Find next page (except on last iteration)
            if page_num < session_pages:
                related_links = get_related_links(driver, visited_links)
                if not related_links:
                    print("‚ùå No related links found. Stopping session.")
                    return False
                
                # 5. Filter out already visited links
                unvisited_links = [link for link in related_links if link not in visited_links]
                if not unvisited_links:
                    print("‚ùå No unvisited related links found. Stopping session.")
                    return False
                
                # 6. Choose one randomly
                next_url = random.choice(unvisited_links)
                print(f"‚û°Ô∏è Selected next page: {next_url}")
                
                # 7. Move cursor to selected link, hesitate, and click
                try:
                    element = driver.find_element(By.XPATH, f"//a[@href='{next_url}']")
                    actions = ActionChains(driver)
                    # Natural cursor movement
                    actions.move_to_element(element).pause(random.uniform(2, 4))  # Hesitation
                    actions.click().perform()
                    print("‚úÖ Clicked on selected link naturally")
                    
                    # 8. Store the clicked link
                    visited_links.add(next_url)
                except Exception as e:
                    print(f"‚ö†Ô∏è Error clicking naturally: {str(e)[:100]}")
                    # Fallback to direct navigation
                    driver.get(next_url)
                    visited_links.add(next_url)
                
                # Only increment pageviews, not click count
                increment_pageviews()
                # Note: increment_click_count() is not called here anymore
                
                # Wait for page to load
                time.sleep(random.uniform(3, 6))
            
        print("üèÅ Session completed successfully")
        return True
        
    except Exception as e:
        print(f"üí• Job error: {str(e)[:100]}")
        return False
    finally:
        stop_event.set()
        cookie_thread_instance.join(timeout=1.0)
        
        # Show report window after session completes or fails
        show_report_window(driver)
